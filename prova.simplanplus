//n1
//syntax errors
//#n1#ERR
//{int x; x=2; int z;}


//n2
//syntax errors
//#n2#ERR
//{int f(int x) {print x+1; {if(x>10)return x-1;} return x+1; } int y=10; y=f(y); if(y==9) print y; else y+8;  }


//n3
//1 semantic errors: the return stm is not the last statement in the block. Unreachable code.
//#n3#ERR
//{int f(int x) {return(2); print(4); } }


//n4
//Type error: block with multiple return statements having mismatching types.
//#n4#ERR
//{int f(int x) { print(4); if(x==1) print x; else return; return(2);} }

//n5
// You had: 2 semantic errors: the return stm is not the last statement in the block. Unreachable code. there cannot be multiple returns in the same block.
//#n5#ERR
//{int f(int x) { {return; print 5; } print(4); if(x==1) print x; else print 3; return(2);} }


//n6
//You had: 1 semantic errors: there cannot be return in the block. It is not a function.
//#n6#ERR
//{int x=1; return; print 4;}


//n7
//Type error: incompatible types in then else branches.
//#n7#ERR
//{int f(int x) {print x+1; {x=1;if(x==1) return 2; else print 2;} return x+1; } f(1);}


//n8
//OK
//#n8#OK
//{int f(int x) {print x+1; {x=1; if(x==1) return x;} return 1; } f(1);}


//n9 
//Type error: block with multiple return statements having mismatching types.
//#n9#ERR
//{int f(int x) {print x+1; {x=1; if(x==1) return ;} return x+1; } f(1);}


//n10
//OK
//#n10#OK
//{void f(int x) {print x+1; {x=1; if(x==1) return ;} x=1; } f(1);}

//n11
//OK
//#n11#OK
//{void f(int x) {print x+1;} f(1);}


//n12
//You had: 1 semantic errors: there cannot be return in the block. It is not a function.
//#n12#ERR
//{int x; return;}

//n13
//Type error: not valid assignment between pointer w and x
//#n13#ERR
//{^^int z; ^^^int w; ^int x = new int; void f(int x) {print x+1; return;} x^=2; z^=x; w^=x; f(6); print(x^+3);}


//n14
//OK
//#n14#OK
//{void f(int x) {int y; return ;} int z=1; int y; if(z==1) {int y;} else {int y;}  }


//n14b
//You had: 1 semantic errors: Var id f already declared
//#n14b#ERR
//{ int f(int x){ int f=3; print(f*x); } int y=2; f(y);}


//n15
//You had: 2 semantic errors:	Var id x already declared 	Missing declaration: k
//#n15#ERR
//{int x=4; bool x = 8; print(k+x);}

//n16
//syntax errors
//#n16#ERR
//{int x=4aaat;}


//n17
//syntax errors
//#n17#ERR
//d{int x=4;}


//n18 
//lexical errors
//#n18#ERR
//#{int x=4;}


//n19
//You had: 1 semantic errors:	the return stm is not the last statement in the block. Unreachable code.
//#n19#ERR
//{ int f() { { return 1; } if (true) return 1;}}


//n20
//#n20#ERR
//{^^int z; int x; x=3; z^^=2;}


//n21
//Type error: cannot assign IntType value for variable z of type BoolType
//#n21#ERR
//{^^bool z; ^int x; x^=2; z^^=x^; }


//n22
//OK
//#n22#OK
//{^^bool z; ^int x= new int; x^=2; z = new ^bool;}

//n23
//Type error: cannot assign IntType value for variable z of type BoolType
//#n23#ERR
//{^^bool z; ^int x; x^=2; z = new ^int;}


//n24
//Type error: too many dereference operations at pointer x
//#n24#ERR
//{^int x; x^^=2;}


//n25
//You had: 1 semantic errors: Var id f already declared
//#n25#ERR
//{ int f(int x){ int f=3; print(f*x); } int y=2; f(y);}


//n26
//OK
//#n26#OK
//{ int f(int x) {^int y = new int; y^ = 1 ; return (y^);} }


//n27		
//Type error: wrong return type for function f
//#n27#ERR
//{ int f(int x) {^int y = new int; y^ = 1 ; return y;} }


//n28
//OK
//#n28#OK
//{^int y = new int; ^int x = new int; y^ = 1; x^ = y^; } 


//n29
//OK
//#n29#OK
//{^int y = new int; ^int x = new int; y^ = 1; x^ = (y^); } 


//n30
//effetti?
//#n30#ERR
//{int f() {^int x = new int; return (x^);} }


//n31
//OK
//#n31#OK
//{int f(int x){return x+1;} int g(int x){return f(x);} int z=2; if(z==f(1)) z=f(1); else z=g(1); }


//n32
// Type error: cannot assign BoolType value for variable z of type IntType
//#n32#ERR
//{int f(int x){return x+1;} bool g(int x){ if(x==1) return true; else return false;} int z=f(1); z=g(2);}


//n33
//OK
//#n33#OK
//{bool g(){ return true; } bool f(){ return false; } if(g()==f()) print 4;}


//n34
//OK
//#n34#OK
//{bool g(){ return true; } bool f(){ return false; } if(!g()==f()) print 4;}


//n35
//Type error: the argument of 'Neg' is not int type.
//#n35#ERR
//{bool g(){ return true; } bool f(){ return false; } if(-g()==f()) print 4;}


//n36
// effetti sulla x?
//#n36#ERR
//{int g(){ return 1; }  ^int x; x^=3; if(g()==x^) print 4;}



//n37
//Type error: too many dereference operations at pointer y
//#n37#ERR
//{void h(^int x, ^int y){ if (y^^==0) delete x ; else { x^ = x^ - 1; h(y,x) ;} }}


//n38
//OK
//#n38#OK
//{  bool g(){return true;} int f(int x) {^int y = new int; g(); y^ = 1 ; return y^;} }


//n40 
//Type error: wrong return type for function f
//#n40#ERR
//{int f(){}}

//n41
//OK
//#n41#OK
//{void f(){}}

//n42 
//Type error: function f cannot be of type pointer.
//#n42#ERR
//{ ^int f (){return new int;}}

//n43
//Type error: wrong usage of expression NewExpNode with variable x
//#n43#ERR
//{^int x = new bool;}

//n44
//Type error: wrong usage of expression DerExpNode with variable b
//#n44#ERR
//{int f(int x) {^int y = new int;  ^bool b= y;}}

//n45
//Type error: not valid assignment between pointer  and new expression
//#n45#ERR
//{^^bool x = new bool;}

//n46
//OK
//#n46#OK
//{^^int n = new ^int; n^= new int; n^^=3; print(n^^-7);}


//n47
//ERR????
//#n47#ERR
//{int f(int a){ return a;} int x; f(x); print x;}

//n48
// dovrebbe dare errore perchè Effect(z)=init, ma non è così.
// aggiungendo in CallNode.checkEffects un for che fa la checkEffects di tutti i parametri, funziona.
//#n48#ERR
//{void f(int x){ print x;} int y=2; int z; f(y+z); }


//n49
// mutua ricorsione
//#n50#ERR
//{ void f(int x){ g(x); } void g(int x){ f(x); } }

//n50
//#n50#ERR
//{ int y=2; void f(){ print y+x; } int x=3;  }


//n51
//#n51#OK
//{void f(int x, int y){ {int z; if(x==0) return; else print x;} print y; } }
 { void f () {int x; {int y; {int z;   return;} print y;}  print x;}  }

//p01
//OK
//#p01#OK
//{^^int x ; ^int y = new int; y^ = 1 ; x = new ^int; x^ = y ; print x^^ ;}


//p02
//You had: 1 semantic errors: Missing declaration: y
//#p02#ERR
//{ ^int x = new int; x^ = 1; delete x; y = x^; }


//p03
//dovrebbe dare errore per l'uso di x dopo delete 
//#p03#ERR
//{void f(^int x, ^int y){delete x; delete y;} ^int x = new int; f(x,x);}

//p04     (per ora OK) 
//#p04#OK
//{void h(^int x, ^int y){ if (y^==0) delete x ; else { x^ = x^ - 1; h(y,x); } }}

//p05
//#p05#ERR
//{void g(^int x, int y){if (y==0) delete x; else {x^= x^-1; g(x,y); delete x;} }  ^int a = new int; int b=0; a^=2; g(a,b);}



//p06
//OK
//#p06#ERR
//{int x = 1; void f(int y) { if (y == 0)  print(x);  else f(y-1);}  f(54); }


//p07
//#p07#OK
//{void f(^int x, int n){if (n==0) {print(x); delete x;} else {^int y = new int; y^ = x^ * n; } } ^int u = new int; u^ = 1; f(u,6); }



//p08
//??????? f(5,4) ok, mentre f(4,5) "reached max memory limit"
//#p08#OK
//{void f(int m, int n){if (m>n) {print(m+n);} else {int x = 1; f(m+1, n+1);} } f(5,4);}